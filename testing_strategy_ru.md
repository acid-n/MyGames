# Стратегия Тестирования Проекта "Alien Invasion"

## 1. Цели Тестирования

Основными целями внедрения и применения автоматизированного тестирования в проекте "Alien Invasion" являются:

*   **Повышение качества кода:** Снижение количества ошибок и регрессий при внесении изменений или добавлении нового функционала.
*   **Обеспечение стабильности:** Гарантия того, что ключевые механики игры работают корректно после каждого изменения.
*   **Ускорение разработки:** Быстрая обратная связь от тестов позволяет раньше выявлять проблемы, сокращая время на отладку.
*   **Упрощение рефакторинга:** Наличие тестов придает уверенность при изменении существующего кода, так как они помогают убедиться, что функциональность не была нарушена.
*   **Документирование кода:** Тесты служат живой документацией, демонстрирующей, как должны работать отдельные компоненты и система в целом.
*   **Проверка корректности управления ассетами:** Уверенность в том, что все необходимые игровые ресурсы (изображения, звуки) доступны и корректно загружаются.

## 2. Типы Тестов и их Применение

### 2.1. Модульные тесты (Unit Tests)

*   **Фокус:** Тестирование наименьших изолированных частей кода – отдельных функций, методов классов. Цель – проверить корректность логики конкретного модуля, изолировав его от зависимостей (с помощью мок-объектов).
*   **Применение в "Alien Invasion":**
    *   **Примеры (уже созданы):**
        *   `TestSettingsInitialization`: Проверка инициализации класса `Settings`, корректности путей к ассетам.
        *   `TestShipLoading`: Проверка создания объекта `Ship` и загрузки его ресурсов (с мокированием Pygame).
        *   `TestScoreboardUpdates`: Проверка обновления счета в `Scoreboard` (с мокированием Pygame).
    *   **Рекомендации по расширению:**
        *   Тестирование методов расчета в `Settings` (например, `calculate_alien_speed`, `calculate_shield_spawn_chance`).
        *   Тестирование логики движения и состояний в `Ship` (например, активация щита, двойного выстрела, проверка границ экрана).
        *   Тестирование логики `Alien` (например, `check_edges`, применение `tint`).
        *   Тестирование методов `GameStats` (например, `reset_stats`, корректность загрузки/сохранения рекорда – с мокированием файловых операций).
        *   Тестирование логики `PowerUp` (если она усложнится, например, разные эффекты при столкновении).
        *   Тестирование функций расчета в `alien_invasion.py` (например, `_create_fleet` в части определения количества пришельцев и рядов, логика назначения бонусов).

### 2.2. Интеграционные тесты (Integration Tests)

*   **Фокус:** Проверка взаимодействия между несколькими компонентами системы. Цель – убедиться, что модули корректно работают вместе.
*   **Применение в "Alien Invasion":**
    *   **Пример 1: `Settings` и `Ship`:** Загрузить реальные настройки из `Settings`, создать `Ship` (с мокированием только Pygame зависимостей, но не `Settings`) и проверить, что корабль использует правильные значения скорости, изображения из настроек.
    *   **Пример 2: `AlienInvasion`, `GameStats`, `Scoreboard`:** Имитировать игровой процесс (например, уничтожение пришельца), проверить, что `GameStats.score` обновляется, и это изменение корректно отражается в `Scoreboard.score_image` (после вызова `prep_score`).
    *   **Пример 3: `Bullet` и `Alien` (коллизии):** Создать реальные объекты `Bullet` и `Alien` (или их группы), имитировать их движение до столкновения и проверить, что коллизия детектируется, и оба объекта удаляются (или помечаются как удаленные). Потребует частичной инициализации Pygame или очень точного мокирования `pygame.sprite.groupcollide` и `rect` атрибутов.
    *   **Пример 4: Выпадение бонуса:** Проверить, что после уничтожения `Alien`, которому был назначен бонус, создается объект `PowerUp` нужного типа.

### 2.3. Тесты ассетов (Asset Tests)

*   **Фокус:** Специализированные тесты для проверки фактического наличия файлов ассетов по путям, указанным в `Settings`, и их базовой корректности.
*   **Применение в "Alien Invasion":**
    *   **Проверка наличия:** Для каждого пути к ассету в `Settings` (изображения, звуки) выполнить `os.path.exists(path)`.
    *   **Проверка загрузки изображений:** Попытаться загрузить каждое изображение с помощью `pygame.image.load(path)`. Если загрузка не удалась, тест провален. Это поможет выявить поврежденные файлы или файлы неподдерживаемого формата на ранней стадии. (Требует инициализации `pygame.display` или использования `pygame.image.get_extended()` и соответствующей обработки).
    *   **Проверка загрузки звуков:** Аналогично для звуков с `pygame.mixer.Sound(path)`. (Требует инициализации `pygame.mixer`).
    *   Эти тесты могут быть выделены в отдельную группу и запускаться, например, перед сборкой дистрибутива или при изменении ассетов.

### 2.4. Тесты пользовательского интерфейса (UI Tests) / Сквозные тесты (End-to-End Tests)

*   **Фокус:** Для игр на Pygame полная автоматизация UI-тестов затруднительна без специализированных инструментов, которые могут "видеть" экран и имитировать ввод пользователя. Однако, можно реализовать частичные проверки.
*   **Применение в "Alien Invasion":**
    *   **Проверка состояний игры:** Убедиться, что игра корректно переключается между состояниями (меню, игра, пауза, конец игры) в ответ на определенные события (например, нажатие кнопки "Новая игра", столкновение корабля с пришельцем при последней жизни).
    *   **Проверка видимости элементов:** Проверить, что в определенных состояниях игры нужные кнопки или элементы интерфейса (например, текст "Пауза") становятся "видимыми" (т.е. их методы `draw` или `blit` вызываются). Это можно сделать путем мокирования методов отрисовки и проверки, были ли они вызваны.
    *   **Реакция на события:** Проверить, что нажатие определенных клавиш (например, стрелки, пробел) или кнопок мыши в правильном игровом состоянии приводит к ожидаемым действиям (например, движение корабля, выстрел, старт игры).
    *   **Next.js (гипотетически):** Если бы в проекте была веб-часть на Next.js (например, для таблицы лидеров онлайн или настроек), то для нее применялись бы стандартные инструменты веб-тестирования:
        *   **Jest с React Testing Library:** Для модульного и интеграционного тестирования React-компонентов.
        *   **Cypress или Playwright:** Для сквозных тестов, имитирующих действия пользователя в браузере.

## 3. Инструменты и Фреймворки

*   **Python:**
    *   **`unittest`:** (Уже используется) Встроенный в Python фреймворк, хорошо подходит для начала. Обеспечивает базовый функционал для написания тестов (классы тестов, методы-тесты, утверждения, `setUp/tearDown`).
    *   **`pytest`:** (Рекомендация для рассмотрения) Сторонний фреймворк, предлагающий более гибкий и менее шаблонный синтаксис для написания тестов. Имеет множество плагинов (например, `pytest-cov` для покрытия кода, `pytest-mock` для удобной работы с моками). Может упростить написание и организацию тестов, особенно для интеграционных.
*   **Мокирование:**
    *   **`unittest.mock`:** (Уже используется) Мощный инструмент для создания мок-объектов и заглушек, позволяющий изолировать тестируемый код от его зависимостей.
*   **Next.js (гипотетически, для веб-части):**
    *   **`Jest`:** Популярный фреймворк для тестирования JavaScript, часто используется с React.
    *   **`React Testing Library`:** Библиотека для тестирования React-компонентов, поощряющая написание тестов, ориентированных на поведение пользователя.
    *   **`Cypress` / `Playwright`:** Инструменты для сквозного тестирования веб-приложений в реальном браузере.

## 4. Приоритеты Тестирования

Тестирование следует начинать с наиболее критичных и нестабильных частей системы:

1.  **Критически важная игровая логика:**
    *   Управление состояниями игры (`AlienInvasion.game_state`, переходы между ними).
    *   Механика подсчета очков (`GameStats.score`, `Scoreboard`).
    *   Управление жизнями игрока (`GameStats.ships_left`, `Ship._ship_hit`).
    *   Логика завершения игры и начала новой игры.
2.  **Загрузка и управление ассетами:**
    *   Корректность путей в `Settings`.
    *   Успешная загрузка основных ассетов (корабль, пришельцы, ключевые звуки). (См. Тесты ассетов).
3.  **Основные игровые механики:**
    *   Движение корабля и пришельцев.
    *   Стрельба и движение пуль.
    *   Механика коллизий (пуля-пришелец, корабль-пришелец, корабль-бонус).
    *   Логика выпадения и применения бонусов.
4.  **Динамическое изменение сложности:**
    *   Проверка корректности изменения параметров игры (скорость, количество врагов) в зависимости от уровня (`Settings.initialize_dynamic_settings`, `Settings.calculate_...`).
5.  **Компоненты с частыми изменениями:** Если какая-то часть кода активно дорабатывается, ее следует покрывать тестами в первую очередь, чтобы отлавливать регрессии.

## 5. Покрытие Кода (Code Coverage)

*   **Цель:** Измерить, какая часть кода выполняется во время запуска тестов. Это не гарантия качества, но хороший индикатор того, какие области не протестированы.
*   **Инструменты:**
    *   **`coverage.py`:** Популярный инструмент для Python. Может использоваться с `unittest` или `pytest`.
    *   **`pytest-cov`:** Плагин для `pytest`, упрощающий интеграцию с `coverage.py`.
*   **Целевые показатели:**
    *   **Начальная цель:** 70-80% покрытия для ключевых модулей (логика игры, управление состояниями, настройки).
    *   **Долгосрочная цель:** 85-95% для критически важных частей. 100% покрытие не всегда является самоцелью и может быть избыточно дорогим, особенно для UI-кода или очень простого кода.
*   **Анализ отчетов:** Регулярно анализировать отчеты о покрытии, чтобы выявлять нетестированные участки кода и принимать решение о необходимости написания для них тестов.

## 6. Интеграция в Процесс Разработки

*   **Локальный запуск тестов:** Разработчики должны запускать тесты локально перед каждым коммитом или пушем изменений в репозиторий.
    *   **Pre-commit хуки:** Можно настроить pre-commit хуки (например, с использованием библиотеки `pre-commit`), которые автоматически будут запускать тесты (и, возможно, линтеры/форматтеры) перед созданием коммита. Это помогает предотвратить попадание сломанного кода в репозиторий.
*   **CI/CD (Continuous Integration / Continuous Delivery):** Если проект будет развиваться командой или использовать систему контроля версий с удаленным репозиторием (например, GitHub, GitLab), рекомендуется настроить CI/CD пайплайн.
    *   Автоматический запуск всех тестов при каждом пуше в основную ветку или при создании Pull Request / Merge Request.
    *   Генерация отчетов о покрытии кода в CI.
    *   Сборка дистрибутива игры (если применимо) только после успешного прохождения всех тестов.

## 7. Рекомендации по Написанию Тестов

*   **Независимость (Isolation):** Каждый тест должен быть независим от других. Результат одного теста не должен влиять на результат другого. Используйте `setUp` для создания чистого окружения для каждого теста.
*   **Скорость (Fast):** Модульные тесты должны выполняться быстро. Медленные тесты замедляют разработку и реже запускаются. Для долгих интеграционных или E2E тестов можно выделить отдельные наборы.
*   **Одна проверка на тест (Single Responsibility):** В идеале, каждый тестовый метод должен проверять один конкретный аспект поведения или одну логическую единицу. Это упрощает понимание причины падения теста.
*   **Понятные имена (Descriptive Names):** Имена тестовых методов должны четко описывать, что именно они проверяют (например, `test_ship_moves_right_on_right_arrow_key`).
*   **`setUp` и `tearDown` / `setUpClass` и `tearDownClass`:**
    *   `setUp`: Выполняется перед каждым тестовым методом. Используется для создания объектов и настройки состояния, необходимого для теста.
    *   `tearDown`: Выполняется после каждого тестового метода. Используется для очистки ресурсов (например, удаление временных файлов).
    *   `setUpClass`: Выполняется один раз перед всеми тестами в классе.
    *   `tearDownClass`: Выполняется один раз после всех тестов в классе.
*   **AAA (Arrange, Act, Assert):** Структурируйте тесты по этому паттерну:
    *   **Arrange (Подготовка):** Настройка начальных условий, создание объектов.
    *   **Act (Действие):** Выполнение тестируемого кода.
    *   **Assert (Утверждение):** Проверка соответствия результата ожидаемому.
*   **Читаемость:** Тесты – это тоже код. Они должны быть чистыми, понятными и хорошо организованными.
*   **Русский язык:** Все текстовые материалы, связанные с тестами, включая комментарии в коде тестов, сообщения об ошибках в утверждениях (если возможно кастомизировать) и документацию (как эта стратегия), должны быть на русском языке для соответствия остальной части проекта.

Эта стратегия тестирования обеспечивает основу для создания надежной и качественной игры "Alien Invasion". Она должна регулярно пересматриваться и адаптироваться по мере развития проекта.
